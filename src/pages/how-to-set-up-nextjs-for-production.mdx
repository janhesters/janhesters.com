import { createPostMetaData } from 'features/posts/posts-factories.js';
import { withPost } from 'hocs/with-post.js';

export const meta = createPostMetaData({
  date: '2020-08-22',
  description: 'Build a React app using Next.js for SEO, fast loading speed and easy hosting on Vercel. Use static analysis tools such as ESLint and Prettier with TypeScript typechecks. Write unit, integration and functional tests using Jest, and React Testing Library. Style your components with Emotion and provide translations with i18next. Use Reach UI for accessibility. Use semantic-release for automatic changelog generation.',
  id: 'ckj4cyudu00001kk577j12npa',
  tags: ['next.js', 'production', 'jest', 'typescript', 'linting', 'eslint', 'prettier', 'commitlint', 'internationalization', 'localization', 'i18n'],
  title: 'How to Set Up Next.js for Production',
  type: 'hidden',
});

export default withPost(meta);

<!-- Alternative title: 12 steps to set up your next.js project for production -->

A bad project can slow you down as your project grows through tech debt and you want to avoid that. Consequently, a good project setup can have compounding returns as your app matures. 

## What Makes a Project Setup Good?

A good project setup helps you to keep being fast in the initial months of your app and allows you to scale your app and your team easily as they grow.

- **Setting standards**: Setting standards and conventions for your code eliminates unnecessary debates. Good standards tend to follow the mainstream because that makes onboarding new developers easier.
- **Testing**: If you write thorough tests from the beginning and make it a habit you can keep test coverage high during the lifetime of your app.
- **Avoiding huge rewrites**: Usually you want to follow [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it) and only implement what you need, but sometimes adding and maintaining a feature takes little extra work if you do it early. For example, introducing i18n early is easy, but adding localization to an existing project is tedious because you have to scan all files and replace all strings. Or deploying your app using CI/CD is easy if you've always done it, but it is a big effort to replace a scheduled release cycle with it.
- **Preparing for success**: Knowing what a project needs takes a lot of experience and discovering unknown unkowns (aka things you didn't know you need / want). It is worth considering all basic needs of large apps from the start. For example, your app is required to meet accessibility standards if you want to sell it in certain countries and you can reach more people if it is accessible.

Even though these guidelines apply to every React project, this guide uses [Next.js](https://nextjs.org/) because it is an amazing framework that is fun to work with and easily deployable.

## Create the Project

Use [`create-next-app`](https://nextjs.org/docs/api-reference/create-next-app) to bootstrap your project.

```
yarn create next-app
# or
npx create-next-app
```

Create `src/` folder and move the `pages/` as well as the `styles/` directory into it.

Run `yarn dev` to make sure your project still works.

## Folder Structure

[Colocate files by feature](https://medium.com/javascript-scene/elements-of-javascript-style-caa8821cb99f) because it keeps related files together and avoids tedious searches through your project.

So instead of

```
src/
├── components/
│   ├── authentication
│   └── user
├── reducers/
│   ├── authentication
│   └── home
├── ...
└── tests/
    ├── authentication
    └── home
```

group your files like this:

```
features/
├── authentication/
│   ├── component
│   ├── reducer
│   └── test
├── ...
└── home/
    ├── component
    ├── reducer
    └── test
```

More precisely, your project is going to look something like the following tree in the end.

```
my-app/
├── public/
│   ├── static/
│   └── favicon.ico
├── src/
│   ├── components/
│   │   ├── ...
│   │   ├── button/
│   │   │   └── button-component-styles.ts
│   │   └── spinner/
│   ├── features/
│   │   ├── ...
│   │   ├── user-authentication/
│   │   │   ├── ...
│   │   │   ├── logout-handler.ts
│   │   │   ├── user-authentication-component-styles.ts
│   │   │   ├── user-authentication-component.tsx
│   │   │   ├── user-authentication-container.tsx
│   │   │   ├── user-authentication-container.test.tsx
│   │   │   ├── user-authentication-reducer.ts
│   │   │   ├── user-authentication-reducer.test.ts
│   │   │   ├── user-authentication-saga.ts
│   │   │   └── user-authentication-saga.test.ts
│   │   └── user-profile/
│   ├── hocs/
│   ├── hooks/
│   ├── middleware/
│   ├── redux/
│   │   ├── root-saga.ts
│   │   ├── root-reducer.ts
│   │   └── store.ts
│   ├── styles/
│   │   ├── ...
│   │   └── theme.ts
│   ├── tests/
│   ├── pages/
│   │   ├── api/
│   │   │   ├── ...
│   │   │   ├── login.ts
│   │   │   └── logout.ts
│   │   ├── [some-feature]/
│   │   ├── ...
│   │   ├── _app.tsx
│   │   ├── _document.tsx
│   │   ├── index.ts
│   │   └── other-feature.ts
│   └── utils/
│       ├── ...
│       ├── cookies.ts
│       └── types.ts
├── ...
├── .env.local
├── .env.local.example
├── .eslintcache
├── .eslintignore
├── .eslintrc.json
├── .gitignore
├── .prettierignore
├── .prettierrc
├── commitlint.config.js
├── emotion.d.ts
├── i18n.js
├── jest.config.ts
├── jest.setup.ts
├── next.env.d.ts
├── package.json
├── README.md
├── tsconfig.json
└── yarn.lock
```

- `public/`: The `public/` folder is used by Next.js for [static file serving](https://nextjs.org/docs/basic-features/static-file-serving). The `static/` folder can hold `locales/`, `images/`, `svgs/` etc.
- `src/`: The `src/` directory contains our code.
  - `components/`: Components that are used by many features (e.g. a generic button) live here.
  - `features/`: This folder groups files by feature. For example you can have an `user-authentication/` folder inside of it that holds the components, reducers, sagas and API handlers related to user authentication.
  - `hocs/`: Higher-order components that are not specific to any feature go here.
  - `hooks/`: Custom React Hooks that don't belong to any feature go here.
  - `middleware/`: If you use [Next.js' API routes](https://nextjs.org/docs/api-routes/introduction), you might want to use the same middleware across multiple routes. This common middleware shared across features goes here.
  - `redux/`: The `redux/` folder contains files specific to Redux and its setup.
  - `styles/`: Global styling and theming files go into the `styles` folder.
  - `tests/`: Shared files across multiple tests such as a custom render function go into the `tests/` folder.
  - `pages/`: The `pages/` folder inside of `src/` takes care of the routing. Inside we can wraps page in React [HOCs](https://janhesters.com/higher-order-components) and API routes in middleware.
  - `utils/`: This folder contains various utility functions that are used by both the client and / or the server.
- Loose files: The rest of the project is various configuration files for the tools we use.

## TypeScript

TypeScript is basically JavaScript with types. It can catch errors for you and [many](https://slack.engineering/typescript-at-slack/) [big](youtube.com/watch?v=P-J9Eg7hJwE) [companies](https://www.youtube.com/watch?v=sjov1k5jexA) are using it. Though you can adopt it gradually in projects, it is beneficial to use it from the get go.

Install TypeScript and the React types.

```
yarn add --dev typescript @types/react @types/node
```

[Convert your project to TypeScript](https://nextjs.org/docs/basic-features/typescript) by creating a `tsconfig.json` in the root of your project.

```json
{
  "compilerOptions": {
    "allowJs": true,
    "baseUrl": "./src",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "lib": ["dom", "dom.iterable", "esnext"],
    "module": "esnext",
    "moduleResolution": "node",
    "noEmit": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true,
    "target": "es5"
  },
  "exclude": ["node_modules"],
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"]
}
```

This config allows [absolute imports](https://nextjs.org/docs/advanced-features/module-path-aliases) from the `src/` folder because we set the `"baseUrl"`.

Lastly, change the extensions of the React files to `.tsx` and the API route to `.ts`. 

Add types to `_app.tsx`.

```tsx
import '../styles/globals.css';

import type { AppProps } from 'next/app';

function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
}

export default MyApp;
```

You also need to add types to the API route.

```ts
import type { NextApiHandler } from 'next';

const handler: NextApiHandler<{ name: string }> = (request, response) => {
  response.statusCode = 200;
  response.json({ name: 'John Doe' });
};

export default handler;
```

When you now run `yarn dev`, Next.js will generate a `next-env.d.ts` for you. Additionally, add a `"type-check"` script to `package.json`.

```json
{
  "type-check": "tsc --pretty --noEmit",
}
```

**Note:** I avoid using TypeScript in my personal projects (except for [packages](https://github.com/janhesters/mock-function)) because [it has a negative ROI on projects that properly use other quality measures](https://medium.com/javascript-scene/the-typescript-tax-132ff4cb175b) (even though it might not feel that way) and use plain JavaScript instead. I included TypeScript in this article because of its popularity.

## Static Analysis

Using ESLint and Prettier you find errors in your code without running it and keep your code style and formatting consistent.

Add ESlint's cache file to your `.gitignore`.

```
# linting
.eslintcache
```

Install ESLint, lint-staged, Prettier and Husky. (Note that we already installed the plugins for Jest and Testing Library here.)

```
yarn add --dev @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint eslint-config-prettier eslint-plugin-import eslint-plugin-jest-dom eslint-plugin-jsx-a11y eslint-plugin-prettier eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-simple-import-sort eslint-plugin-testing-library eslint-plugin-unicorn husky lint-staged prettier
```

Create the next 4 files in the root of your project, start with `.eslintignore`.

```
**/node_modules/*
**/out/*
**/.next/*
```

Then an `.eslintrc.json`.

```json
{
  "env": {
    "browser": true,
    "commonjs": true,
    "es6": true,
    "jest": true,
    "node": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:import/errors",
    "plugin:import/warnings",
    "plugin:jsx-a11y/recommended",
    "plugin:testing-library/recommended",
    "plugin:jest-dom/recommended",
    "plugin:prettier/recommended",
    "plugin:unicorn/recommended",
    "prettier",
    "prettier/react",
    "prettier/unicorn",
    "prettier/@typescript-eslint"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaFeatures": {
      "jsx": true
    },
    "ecmaVersion": 2020,
    "sourceType": "module"
  },
  "plugins": [
    "@typescript-eslint",
    "jest-dom",
    "testing-library",
    "react-hooks",
    "simple-import-sort",
    "unicorn",
    "prettier"
  ],
  "rules": {
    "@typescript-eslint/explicit-function-return-type": 0,
    "@typescript-eslint/explicit-module-boundary-types": 0,
    "@typescript-eslint/no-empty-function": 0,
    "@typescript-eslint/no-var-requires": 0,
    "import/order": "off",
    "jsx-a11y/anchor-is-valid": [
      "error",
      {
        "aspects": ["invalidHref", "preferButton"],
        "components": ["Link"],
        "specialLink": ["hrefLeft", "hrefRight"]
      }
    ],
    "prettier/prettier": "error",
    "react-hooks/exhaustive-deps": "warn",
    "react-hooks/rules-of-hooks": "error",
    "react/display-name": "off",
    "react/prop-types": "off",
    "react/react-in-jsx-scope": "off",
    "simple-import-sort/exports": "error",
    "simple-import-sort/imports": "error",
    "unicorn/no-reduce": "off",
    "unicorn/no-array-reduce": "off",
    "unicorn/no-array-callback-reference": "off",
    "unicorn/no-fn-reference-in-iterator": "off",
    "unicorn/prevent-abbreviations": [
      "error",
      {
        "whitelist": {
          "Props": true,
          "props": true,
          "i18n": true,
          "next-env.d": true,
          "next-i18next.config": true
        }
      }
    ]
  },
  "settings": {
    "import/resolver": {
      "node": {
        "paths": ["src"],
        "extensions": [".js", ".jsx", ".ts", ".tsx"]
      }
    },
    "react": {
      "version": "detect"
    }
  }
}
```

Setting the `import/resolver` node path allows ESLint to know about the absolute imports we configured with TypeScript.

Also a `.prettierignore` file.

```
node_modules
.next
yarn.lock
package-lock.json
public
```

And a `.prettierrc`.

```json
{
  "arrowParens": "avoid",
  "bracketSpacing": true,
  "htmlWhitespaceSensitivity": "css",
  "insertPragma": false,
  "jsxBracketSameLine": false,
  "jsxSingleQuote": false,
  "printWidth": 80,
  "proseWrap": "always",
  "quoteProps": "as-needed",
  "requirePragma": false,
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "all",
  "useTabs": false
}
```

Add scripts and a lint-staged section to your `package.json`.

```json
{
  "lint-staged": {
    "*.@(ts|tsx)": [
      "yarn lint",
      "yarn format"
    ]
  },
  "scripts": {
    "format": "prettier --write .",
    "lint": "eslint --cache . --ext ts --ext tsx --ext js",
  }
}
```

## Commitlint & Husky

Install [Husky](https://github.com/typicode/husky) and [Commitlint](https://github.com/conventional-changelog/commitlint) for conventional commits. This can make debugging using Git easier and enables streamlining releases using automatic changelog generation.

```
yarn add --dev husky @commitlint/{config-conventional,cli}
```

Create a `commitlint.config.js` configuration file in you project root.

```js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'references-empty': [2, 'never'],
  },
};
```

Add a `"husky"` (for Husky V4) script to your `package.json`.

```json
{
  "husky": {
    "hooks": {
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS",
      "pre-commit": "lint-staged && yarn type-check"
    }
  }
}
```

**Note:** You might want to [install commitizen globally](https://github.com/commitizen/cz-cli) and commit using `npx cz`.

## State Management

One of the most popular ways to manage state is [Redux](https://redux.js.org/). The [Redux Saga](https://redux-saga.js.org/) middleware allows you to isolate side-effects. Even though both can be a boilerplaty, they scale really well and are easy to test and debug. We'll use [Redux Toolkit](https://redux-toolkit.js.org/) to create our store and reduce our boilerplate.

Add Redux Toolkit, [React Redux](https://react-redux.js.org/) and Redux Saga.

```
yarn add @reduxjs/toolkit react-redux redux-logger redux-saga && yarn add --dev @types/react-redux
```

Create a `redux/` folder. Inside of `redux/` we need three files: one for the root saga, one for the root reducer and one for the store.

Create the `root-saga.ts` in which you can replace the `helloWorld()` saga with actual sagas later.

```ts
import { all, call } from 'redux-saga/effects';

function* helloWorld() {
  yield call(console.log, 'Hello World!');
}

function* rootSaga() {
  yield all([helloWorld()]);
}

export default rootSaga;
```

Next create the `root-reducer` with a dummy `test` slice.

```ts
import { combineReducers } from '@reduxjs/toolkit';

const rootReducer = combineReducers({
  test: (state = {}) => state,
});

const rootState = rootReducer(undefined, { type: '' });

export type RootState = ReturnType<typeof rootReducer>;

export { rootReducer, rootState };
```

We export the root state and its type. This can come in handy for tests and connecting components to Redux.

**Note:** We skip tests for Redux in this tutorial, but you might want to read ["Unit Testing Reducers"](https://janhesters.com/unit-testing-reducers) because you will learn how to write good tests for Redux.

The create a `useStore` hook inside of `store.ts`.

```ts
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/ban-types */
import {
  AnyAction,
  configureStore,
  Dispatch,
  EnhancedStore,
  getDefaultMiddleware,
  Middleware,
  MiddlewareArray,
} from '@reduxjs/toolkit';
import { useMemo } from 'react';
import createSagaMiddleware from 'redux-saga';

import { rootReducer, RootState, rootState } from './root-reducer';
import rootSaga from './root-saga';

/**
 * Constants
 */

const isClient = typeof window !== 'undefined';
const isDevelopment = process.env.NODE_ENV === 'development';
const isProduction = process.env.NODE_ENV === 'production';

/**
 * Default middleware
 */

const middleware = getDefaultMiddleware({ thunk: false });

/**
 * Setup Redux logger
 */

if (isDevelopment) {
  const { logger } = require(`redux-logger`);

  middleware.push(logger);
}

/**
 * Setup store
 */

let store:
  | undefined
  | EnhancedStore<
      RootState,
      AnyAction,
      MiddlewareArray<Middleware<{}, any, Dispatch<AnyAction>>>
    >;

function initStore(preloadedState = rootState) {
  const sagaMiddleware = createSagaMiddleware();

  const _store = configureStore({
    devTools: !isProduction,
    preloadedState,
    reducer: rootReducer,
    middleware: [...middleware, sagaMiddleware],
  });

  // Avoid memory leaks.
  if (isClient) {
    sagaMiddleware.run(rootSaga);
  }

  return _store;
}

const initializeStore = (preloadedState: RootState) => {
  let _store = store ?? initStore(preloadedState);

  if (preloadedState && store) {
    _store = initStore({
      ...store.getState(),
      ...preloadedState,
    });
    store = undefined;
  }

  // This check needs to run in the functions scope.
  if (typeof window === 'undefined') return _store;

  if (!store) store = _store;

  return _store;
};

function useStore(initialState: RootState) {
  const store = useMemo(() => initializeStore(initialState), [initialState]);
  return store;
}

export { useStore };
```

Wrap the component tree inside of the provider in `_app.tsx`.

```tsx
import '../styles/globals.css';

import type { AppProps } from 'next/app';
import { Provider } from 'react-redux';
import { useStore } from 'redux/store';

function MyApp({ Component, pageProps }: AppProps) {
  const store = useStore(pageProps.initialReduxState);

  return (
    <Provider store={store}>
      <Component {...pageProps} />
    </Provider>
  );
}

export default MyApp;
```

If you run your app now, you should see `"Hello World!"` printed to the console.

## Styling

We'll use [Emotion](https://emotion.sh) for styling because it is gives us a great developer experience while still being light-weight. We combine it with [polished](https://polished.js.org/) which can help us with our CSS-in-JS.

```
yarn add @emotion/react @emotion/styled polished styled-breakpoints && yarn add --dev @emotion/babel-plugin
```

Create a `.babelrc` file to use Emotion's Babel plugin.


```json
{
  "presets": [
    [
      "next/babel",
      {
        "preset-react": {
          "runtime": "automatic",
          "importSource": "@emotion/react"
        }
      }
    ]
  ],
  "plugins": ["@emotion/babel-plugin"]
}
```

Create a `emotion.d.ts` file, which we will use to type the theme of our app.

```ts
import type { SerializedStyles } from '@emotion/react';

declare module '@emotion/react' {
  export interface Theme {
    colors: {
      background: string;
      border: string;
      primary: string;
      text: string;
    };

    padding: {
      medium: SerializedStyles;
    };

    radius: {
      medium: SerializedStyles;
    };
  }
}
```

Here, `radius.medium` is a `SerializedStyles` object which allows us to make it a value from `polished`.

Now within the `styles/` folder delete all files and create `styles.ts`.

```ts
import { css, Theme } from '@emotion/react';
import { rem } from 'polished';

const rawColors = {
  /**
   * Black
   */

  black100: '#000',

  /**
   * White
   */

  white100: '#fafafa',
  white300: '#eaeaea',

  /**
   * Blue
   */

  blue400: '#0070f3',
};

const themeColors = {
  background: rawColors.white100,
  border: rawColors.white300,
  primary: rawColors.blue400,
  text: rawColors.black100,
};

const colors = {
  /* You might want to add in other colors later ... */
  ...themeColors,
};

const padding = {
  medium: css`
    ${rem(16)}
  `,
}

const radius = {
  medium: css`
    ${rem(4)}
  `,
};

const theme: Theme = {
  colors,
  padding,
  radius,
};

export default theme;
```

Create a custom hook `src/hooks/use-toggle-outline.ts`. It will allow us to activate and deactivate outline based on mouse or keyboard usage. [Having outline is critical for many users who rely on keyboards](https://medium.com/better-programming/a11y-never-remove-the-outlines-ee4efc7a9968) and removing it programatically allows you to give mouse users the option to activate it.

```ts
import { useEffect, useState } from 'react';

/**
 * @returns A boolean `hideOutline` that indicates whether to hide the outline.
 */
function useToggleOutline() {
  const [hideOutline, setHideOutline] = useState(true);

  useEffect(() => {
    const handleMousedown = () => {
      setHideOutline(true);
    };
    const handleKeydown = () => {
      setHideOutline(false);
    };

    document.addEventListener('mousedown', handleMousedown);
    document.addEventListener('keydown', handleKeydown);

    return () => {
      document.removeEventListener('mousedown', handleMousedown);
      document.removeEventListener('keydown', handleKeydown);
    };
  }, []);

  return hideOutline;
}

export default useToggleOutline;
```

With `useToggleOutline` ready, create `styles/global-styles.tsx`.

```tsx
import { css, Global } from '@emotion/react';
import useToggleOutline from 'hooks/use-toggle-outline';
import { rem } from 'polished';

function GlobalStyles() {
  const hideOutline = useToggleOutline();

  return (
    <Global
      styles={css`
        html {
          box-sizing: border-box;
        }
        *,
        *:before,
        *:after {
          box-sizing: inherit;
        }

        html,
        body,
        #__next {
          height: 100vh;
        }

        body {
          margin: ${rem(0)};
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
            Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        #__next {
          display: flex;
          flex-direction: column;
        }

        a {
          text-decoration: none;
        }

        ul {
          list-style: none;
          margin: ${rem(0)};
          padding: ${rem(0)};
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        p {
          margin: ${rem(0)};
        }

        ${hideOutline &&
        css`
          outline: none;
        `}
      `}
    />
  );
}

export default GlobalStyles;
```

Here you can set the defaults that you like. I usually remove margins from headings, lists and paragraphs and make sure the body of my page always fills the full height.

Use the `theme` and the `GlobalStyles` inside `_app.tsx`.

```tsx
import { ThemeProvider } from '@emotion/react';
import type { AppProps } from 'next/app';
import { Provider } from 'react-redux';
import { useStore } from 'redux/store';
import GlobalStyles from 'styles/global-styles';
import theme from 'styles/theme';

function MyApp({ Component, pageProps }: AppProps) {
  const store = useStore(pageProps.initialReduxState);

  return (
    <Provider store={store}>
      <ThemeProvider theme={theme}>
        <GlobalStyles />

        <Component {...pageProps} />
      </ThemeProvider>
    </Provider>
  );
}

export default MyApp;
```

Create `features/home/` and inside `home-page-component-styles.ts`, `home-page-component.tsx` and `home-page-container.tsx`.

Create the styles for an anchor tag, a heading and the main content.

```ts
import styled from '@emotion/styled';
import { rem } from 'polished';

const Anchor = styled.a`
  color: ${({ theme }) => theme.colors.primary};

  &:active,
  &:focus,
  &:hover {
    text-decoration: underline;
  }
`;

const Heading = styled.h1`
  border-radius: ${({ theme }) => theme.radius.medium};
  border: ${rem(1)} solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.padding.medium};
`;

const Main = styled.main`
  align-items: center;
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  display: flex;
  flex-direction: column;
  flex: 1;
  justify-content: center;
  padding: ${({ theme }) => theme.padding.medium};
`;

export { Anchor, Heading, Main };
```

Then use them in the home page's display component.

```tsx
import { Anchor, Heading, Main } from './home-page-component-styles';

const HomePageComponent = () => (
  <Main>
    <Heading>
      Hello, Welcome to{' '}
      <Anchor
        href="https://janhesters.com"
        target="_blank"
        rel="noopener noreferrer"
      >
        janhesters.com
      </Anchor>
      !
    </Heading>
  </Main>
);

export default HomePageComponent;
```

Lastly, export the component from the container.

```tsx
import HomePageComponent from './home-page-component';

export default HomePageComponent;
```

The ["display" and "container" component pattern](https://redux.js.org/faq/react-redux#should-i-only-connect-my-top-component-or-can-i-connect-multiple-components-in-my-tree) is typically used with Redux do isolate the UI from the logic. Additionally, it [makes the components easier to test](https://janhesters.com/testing-library-the-rite-way).

Now replace the content of `src/pages/index.ts` with the following code to export the `HomePageContainer`.

```ts
import HomePageContainer from 'features/home/home-page-container';

export default HomePageContainer;
```

Exporting pages like this is an excellent use case for abstracting common logic away with [HOCs](https://janhesters.com/higher-order-components) and wrapping your pages with a [composed `page` HOC](https://medium.com/javascript-scene/do-react-hooks-replace-higher-order-components-hocs-7ae4a08b7b58).

## Internationalization

Install [next-18next](https://github.com/isaachinman/next-i18next).

```
yarn add next-i18next
```

Create a `next-i18next.config.js` file.

```js
const path = require('path')

module.exports = {
  defaultLocale: 'en',
  locales: ['en'],
  localePath: path.resolve('./public/static/locales')
}
```

As you add languages, you'll need to add them to the `locales` key.

Create the `public/static/locales/` folder which will contain a folder per language. So far we only have English and the home folder, so create `public/static/locales/en/common.json` will suffice.

```json
{
  "appName": "janhesters.com"
}
```

And create `home.json`.

```json
{
  "welcome-to": "Hello, Welcome to"
}
```

Activate i18n by creating a `next.config.js`.

```js
module.exports = {
  i18n: {
    defaultLocale: 'en',
    locales: ['en', 'de'],
  },
};
```

Wrap your app in the `appWithTranslation` HOC.

```tsx
import { ThemeProvider } from '@emotion/react';
import type { AppProps } from 'next/app';
import { appWithTranslation } from 'next-i18next';
import { Provider } from 'react-redux';
import { useStore } from 'redux/store';
import GlobalStyles from 'styles/global-styles';
import theme from 'styles/theme';

function MyApp({ Component, pageProps }: AppProps) {
  const store = useStore(pageProps.initialReduxState);

  return (
    <Provider store={store}>
      <ThemeProvider theme={theme}>
        <GlobalStyles />

        <Component {...pageProps} />
      </ThemeProvider>
    </Provider>
  );
}

export default appWithTranslation(MyApp);
```

You'll need to fetch the namespaces using `getStaticProps` in `pages/index.ts`.

```ts
import HomePageContainer from 'features/home/home-page-container';
import type { GetStaticProps } from 'next';
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';

export default HomePageContainer;

export const getStaticProps: GetStaticProps = async ({ locale }) => ({
  props: {
    ...(await serverSideTranslations(locale, ['common', 'home'])),
  },
});
```

Swap the strings in `home-page-component.tsx` with `t` function calls.

```tsx
import type { TFunction } from 'next-i18next';

import { Anchor, Heading, Main } from './home-page-component-styles';

const HomePageComponent = ({ t }: { t: TFunction }) => (
  <Main>
    <Heading>
      {t('home:welcome-to') + ' '}
      <Anchor
        href="https://janhesters.com"
        target="_blank"
        rel="noopener noreferrer"
      >
        {t('common:appName')}
      </Anchor>
      !
    </Heading>
  </Main>
);

export default HomePageComponent;
```

Then wrap the `home-page-container.tsx` in a `withTranslation` HOC.

```ts
import { withTranslation } from 'next-i18next';

import HomePageComponent from './home-page-component';

export default withTranslation()(HomePageComponent);
```

If you restart your app now, you should see the translations working. This setup automatically allows users to use domain specific routing (e.g. `https://my-app.com/de/whatever` for german translations). But you can also [imperateively transition between locales](https://nextjs.org/docs/advanced-features/i18n-routing#transition-between-locales).

## Accessibility

[Reach UI](https://reach.tech/) is a library that supplies easy to customize and accessible components. There is no specific component from Reach UI that is needed in every app. Therefore, I'm omitting an example from this tutorial. Make sure to check the library when you implement features to see how you can make your next UI accessible.

Additionally, make sure you use tools like `jest-axe` (see below) if available to get some confidence about the accessibility of your components.

## Testing

We use [Jest](https://jestjs.io/) as our test framework together with [React Testing Library](@testing-library/react).

```
yarn add --dev jest eslint-plugin-jest-dom @types/jest @testing-library/jest-dom @testing-library/user-event @testing-library/react jest-axe @types/jest-axe ts-node
```

Create a `jest.setup.ts` file.

```ts
import '@testing-library/jest-dom';
import 'jest-axe/extend-expect';
```

And then a `jest.config.ts`.

```ts
export default {
  moduleDirectories: ['node_modules', 'src'],
  setupFilesAfterEnv: ['./jest.setup.ts'],
};
```

Add test scripts to your `package.json`.

```json
"test": "jest",
"test:watch": "jest --watch"
```

Create a `src/tests/i18n.ts` file that exports all translations.

```ts
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

import common from '../../public/static/locales/en/common.json';
import home from '../../public/static/locales/en/home.json';

const resources = {
  en: {
    common,
    home,
  },
};

i18n.use(initReactI18next).init({ fallbackLng: 'en', lng: 'en', resources });

export { i18n };
```

Create a custom render in `src/tests/render.tsx` that uses the wrappers for i18n, Emotion and Redux.

```tsx
import { ThemeProvider } from '@emotion/react';
import { configureStore } from '@reduxjs/toolkit';
import { render } from '@testing-library/react';
import { ComponentType, ReactElement } from 'react';
import { I18nextProvider } from 'react-i18next';
import { Provider } from 'react-redux';
import { rootReducer, rootState } from 'redux/root-reducer';
import theme from 'styles/theme';

import { i18n as index18n } from './i18n';

const customRender = (ui: ReactElement, { reduxState = rootState } = {}) => {
  const store = configureStore({
    reducer: rootReducer,
    preloadedState: reduxState,
  });

  const AllTheProviders: ComponentType = ({ children }) => (
    <I18nextProvider i18n={index18n}>
      <Provider store={store}>
        <ThemeProvider theme={theme}>{children}</ThemeProvider>
      </Provider>
    </I18nextProvider>
  );

  return render(ui, { wrapper: AllTheProviders });
};

export default customRender;
```

Now export them from `src/tests/test-helpers.ts`;

```ts
export * from '@testing-library/react';
import render from './render';

export { render };
```

Now write your test in `src/features/home/home-page-container.test.tsx`.

```tsx
import { axe } from 'jest-axe';
import { render, screen } from 'tests/test-helpers';

import HomePageContainer from './home-page-container';

describe('Home page container', () => {
  test('it renders a link to the project', async () => {
    const { container } = render(<HomePageContainer />);

    const results = await axe(container);
    expect(results).toHaveNoViolations();

    expect(
      screen.getByRole('link', { name: /janhesters.com/i }),
    ).toBeInTheDocument();
  });
});
```

Notice how we use [`jest-axe`](https://github.com/nickcolley/jest-axe) to guard against some accessibility violations. Keep in mind that only about 30% of accessibility issues can be found using automated testing.

**Note:** I strongly prefer to [use RITEway instead of Jest](https://janhesters.com/testing-library-the-rite-way) because [RITEway forces you to write good tests](https://medium.com/javascript-scene/rethinking-unit-test-assertions-55f59358253f) and [Jest is unreasonably slow](https://www.reddit.com/r/javascript/comments/kmhej0/askjs_jest_is_so_slow_why_jest/). But again, I chose Jest for this tutorial because its the most popular testing framework and pretty easy to set up.

## Search Engine Optimization

SEO will make your product easier to find for your customers. Add Next SEO.

```
yarn add next-seo
```

Create a `next-seo.config.ts` file.

```ts
import type { DefaultSeoProps } from 'next-seo';

const defaultSeoProps: DefaultSeoProps = {
  title: 'My App',
  description: 'My cool app that I build using a tutorial from janhesters.com.',
  canonical: 'https://my-app.com',
  openGraph: {
    type: 'website',
    locale: 'en_IE',
    url: 'https://www.my-app.com/',
    site_name: 'My App',
  },
  twitter: {
    handle: '@janhesters',
    site: '@site',
    cardType: 'summary_large_image',
  },
};

export default defaultSeoProps;
```

It contains the default values. We can add the default SEO in `_app.tsx`.

```tsx
import { ThemeProvider } from '@emotion/react';
import type { AppProps } from 'next/app';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { appWithTranslation } from 'next-i18next';
import { DefaultSeo } from 'next-seo';
import { Fragment } from 'react';
import { Provider } from 'react-redux';
import { useStore } from 'redux/store';
import GlobalStyles from 'styles/global-styles';
import theme from 'styles/theme';

import SEO from '../../next-seo.config';

function MyApp({ Component, pageProps }: AppProps) {
  const store = useStore(pageProps.initialReduxState);

  return (
    <Fragment>
      <DefaultSeo {...SEO} />

      <Provider store={store}>
        <ThemeProvider theme={theme}>
          <GlobalStyles />

          <Component {...pageProps} />
        </ThemeProvider>
      </Provider>
    </Fragment>
  );
}

export default appWithTranslation(MyApp);
```

You can add page specific SEO using the `NextSeo` component.

```tsx
import type { TFunction } from 'next-i18next';
import { NextSeo } from 'next-seo';
import { Fragment } from 'react';

import { Anchor, Heading, Main } from './home-page-component-styles';

const HomePageComponent = ({ t }: { t: TFunction }) => (
  <Fragment>
    <NextSeo title={t('common:appName')} />

    <Main>
      <Heading>
        {t('home:welcome-to') + ' '}
        <Anchor
          href="https://janhesters.com"
          target="_blank"
          rel="noopener noreferrer"
        >
          {t('common:appName')}
        </Anchor>
        !
      </Heading>
    </Main>
  </Fragment>
);

export default HomePageComponent;
```

## Repository, Pipelines & Hosting

I chose GitHub and Vercel for this tutorial because I'm very familiar with them. You can choose alternatives like GitLab, Netlify or any other service you're comfortable with.

[Create a new repository](https://github.com/new) on GitHub.

Create Next App might have already created a Git configuration for you. You can either go from here, or delete it and start from scratch. I'll do the latter.

Delete your current Git folder.

```
rm -rf ./git
```

Then initialize Git, add the README and push it to your repo.

```
git init
git add README.md
git commit -m "feat: first commit

Creates the project with a README.

re #1
"
git branch -M main
git remote add origin git@github.com:<your-account>/<your-app>.git
git push -u origin main
```

Go to your repository (under `https://github.com/<your-account>/<your-app>/labels`), delete the existing labels and create labels that correspond to the conventional commit types.

| label    | description                                                                                                 |
|----------|-------------------------------------------------------------------------------------------------------------|
| build    | Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)         |
| ci       | Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs) |
| chore    | Other changes that don't modify src or test files                                                           |
| docs     | Documentation only changes                                                                                  |
| feat     | A new feature                                                                                               |
| fix      | A bug fix                                                                                                   |
| perf     | A code change that improves performance                                                                     |
| refactor | A code change that neither fixes a bug nor adds a feature                                                   |
| revert   | Reverts a previous commit                                                                                   |
| style    | Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)      |
| test     | Adding missing tests or correcting existing tests                                                           |

Go to your project's "Settings" and check "Allow rebase merging" under "Merge button" (uncheck the other two options) as well as "Automatically delete head branches".

Click on "Branches" and create a new branch protection rule for the `main` branch. Check the "Require pull request reviews before merging" and "Require status checks to pass before merging" boxes (the former, only when you're at least two collaborators working on the project so you can review each other's PRs) and click "Create".

You can use [GitHub Actions](https://docs.github.com/en/free-pro-team@latest/actions) to automate dependency updates for security and to set up a [CI/CD](https://en.wikipedia.org/wiki/CI/CD) process for your PRs.

Create a `.github/dependabot.yml` file at the root of your project.

```yml
version: 2
updates:
  - package-ecosystem: 'npm'
    directory: '/'
    schedule:
      interval: 'daily'
    commit-message:
      prefix: 'build'
    labels:
      - 'build'
```

Then create a `.github/workflows/pull-request.yml` workflow which runs tests and linting whenever you do a pull request.

```yml
name: Pull Request

on: [pull_request]

jobs:
  testing:
    strategy:
      fail-fast: false
      matrix:
        command:
          - lint
          - test
          - type-check
    name: ${{ matrix.command }}
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout'
        uses: actions/checkout@v2
      - name: 'Cache Yarn'
        uses: actions/cache@v2
        with:
          path: |
            ~/cache
            !~/cache/exclude
            **/node_modules
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-
      - name: 'Install dependencies'
        run: yarn install --frozen-lockfile
      - name: 'Run ${{ matrix.command }}'
        run: yarn ${{ matrix.command }}
  commitlint:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    if: github.actor != 'dependabot[bot]' && github.actor != 'dependabot-preview[bot]'
    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - uses: wagoid/commitlint-github-action@v1
  auto-approve:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    if:
      github.actor == 'dependabot[bot]' || github.actor ==
      'dependabot-preview[bot]'
    steps:
      - uses: hmarr/auto-approve-action@v2.0.0
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
```

Add semantic-release to your project.

```
yarn add --dev semantic-release @semantic-release/changelog @semantic-release/git
```

Create a `.releaserc` file.

```json
{
  "branches": [
    "main"
  ],
  "plugins": [
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    "@semantic-release/npm",
    [
      "@semantic-release/git",
      {
        "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
      }
    ],
    "@semantic-release/github"
  ]
}
```

Make sure `"private": true` is set in your `package.json`.

Follow [these docs](https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token) to create a personal access token. You need to check the "repo" box when creating it. Add the token as a secret for the repo under the name `GH_TOKEN`.

Create a `.github/workflows/release.yml` workflow.

```yml
name: Release
on:
  push:
    branches:
      - main

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          persist-credentials: false
      - name: Setup Node.js
        uses: actions/setup-node@v1
        with:
          node-version: 12
      - name: Install dependencies
        run: yarn install --frozen-lockfile
      - name: Build
        run: yarn build
      - name: Release
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: npx semantic-release
```

## Dark Mode

## Feature flags

## E2E Tests

## Browserstack

## Capturing Errors

You also want to capture errors. I didn't provide an example here because it depends on the service. I like to use Sentry. Whatever you're using, make sure you're enabling source maps.
