---
title: "Secret Techniques For Cursor's New Slash Commands"
datePublished: '2025-09-15'
description: 'Execute queries and mutations by using the correct execution policy and polyfills.'
thumbnailUrl: ''
isDraft: true
---

import { getUrl } from '../lib/misc';
import { getSocialsMetaForBlogPost } from '../features/blog/blog-helpers';

export function loader({ request }) {
  return getUrl(request);
}

export const meta = ({ data }) => getSocialsMetaForBlogPost({
  ...frontmatter,
  url: data,
});

## {frontmatter.title}

This is a Cursor slash command.

You can use Slash commands like this to automate tasks in your workflow.

This is a brand new feature in Cursor.

And no it's not one of those features that you'll never end up using.

This one is really useful if you know how to use it correctly.

BTW, I'm Jan CTO of ReactSquad. Our teams use Cursor every day, and I'm also trained in AIDD by Eric Elliott the author of "The Art of Effortless Programming".

You're going to learn some secret techniques to get the most out of Slash commands.

For example, here is how you can write the Slash command for auto-generating a changelog for your repository.

```md title=".cursor/commands/log.md"
# log

Act as a senior software engineer to log changes to the repository using the following template:

```
## $date

- $emoji - $change1
- $emoji -$change2
```

# Emojis

Use the following emoji to represent the change:

- ðŸš€ - new feature
- ðŸ› - bug fix
- ðŸ“ - documentation
- ðŸ”„ - refactor
- ðŸ“¦ - dependency update
- ðŸŽ¨ - design
- ðŸ“± - UI/UX
- ðŸ“Š - analytics
- ðŸ”’ - security

Constraints {
  Always use reverse chronological order.
  Add most recent changes to the top.
  Never log about logging. Avoid logging meta-work. Instead, log salient, user-impacting changes.
  For each change, follow conventional commit messages:
    ```
    feat(scope): description

    body
    ```
  You must include a body.
}


gitChanges() {
  git add .
  git --no-pager diff --cached
}

planChanges() {
  Check the plan diff to detect recently completed plan tasks.
}

detectChanges() {
  gitChanges |> planChanges |> logDetectedChanges
}
```

This command is written in SudoLang.

[SudoLang](https://github.com/paralleldrive/sudolang-llm-support/tree/main) is a programming language specifically designed to collaborate with AI language models.

Using SudoLang saves you tokens and increases the instruction following accuracy from your LLMs.

You can also chain Slash commands together.

Let's create a another Slash command for commiting your changes to the repository.

```md title=".cursor/commands/commit.md"
# Commit

Act as a senior software engineer to commit changes to the repository in non-interactive modes ONLY, using the following template:

"$type${[(scope)]}{[!]}: $description":where `[]` is optional and `!` is a breaking change

Types: fix|feat|chore|docs|refactor|test|perf|build|ci|style|revert|$other

If we haven't logged the latest changes yet, use @log.md to log changes before committing.

Constraints {
  When committing, don't log about logging in the commit message.
  Use multiple -m flags, one for each log entry.
  Limit the first commit message line length to 50 characters.
  Use conventional commits with a scope, title and body.
}
```

If you now run this `/commit` command in the same window where you ran the `/log` command, it will commit your changes to the repository for you with a beautiful commit message.

### Quick Tips

- Use SudoLang to write your Slash commands. There is really a lot more to writing good prompts, so if you want a SudoLong crash course video, please let me know in the comments below.
- Keep your Slash commands short to manage your context efficiently. Aim for less 150 lines of code.
